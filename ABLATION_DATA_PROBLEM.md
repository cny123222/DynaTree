# 🚨 消融实验数据问题分析

## ❌ **无剪枝数据异常**

### **问题1: Path Length不随深度增加**

```
Depth | Avg Path Length | 预期
------|----------------|------
D=4   | 4.73           | ~4-5
D=5   | 4.83           | ~5-6
D=6   | 4.83           | ~6-7  ❌ 应该更长！
D=7   | 4.83           | ~7-8  ❌ 应该更长！
```

**问题**: D=5, D=6, D=7的path length都是4.83，几乎不变！

### **问题2: Throughput不随深度变化**

```
Depth | Throughput | 预期趋势
------|-----------|----------
D=4   | 97.4 t/s  | 较高（树小）
D=5   | 63.6 t/s  | 下降
D=6   | 63.6 t/s  | 继续下降 ❌ 但实际不变！
D=7   | 63.4 t/s  | 继续下降 ❌ 但实际不变！
```

**问题**: D=5, D=6, D=7的吞吐量几乎一样（63.4-63.6 t/s）

### **问题3: 无剪枝的Path Length比有剪枝短**

```
配置                    | Avg Path | Throughput
------------------------|----------|------------
D=7, B=2, 无剪枝 (t=0.0)| 4.83     | 63.4 t/s
D=7, B=2, 有剪枝 (t=0.05)| 5.81     | 182.7 t/s
```

**问题**: 无剪枝应该生成更大的树，path length应该更长才对！

---

## 🔍 **根本原因分析**

### **可能原因1: max_nodes限制**

代码中可能有`max_tree_nodes`限制，即使设置了`pruning_enabled=False`，也会因为节点数超限而停止生成。

**证据**:
- D=5, D=6, D=7的性能几乎一样
- Avg Path Length停留在~4.8
- 可能触发了某个隐式上限

### **可能原因2: 实验配置错误**

`pruning_enabled=False`可能没有真正关闭剪枝，或者：
- threshold=0.0被解释为"剪掉所有概率<0的分支"
- 存在其他隐式剪枝逻辑

### **可能原因3: Acceptance计算错误**

Avg Path Length可能统计的不是树的实际大小，而是最终接受的路径长度。如果是这样：
- 无剪枝生成了大树，但只接受了短路径
- 导致path length看起来很短

但这解释不了为什么D=5, D=6, D=7的吞吐量一样。

---

## ✅ **数据一致性检查**

### **Baseline一致性**

```
实验            | Baseline  | 差异
----------------|-----------|------
剪枝消融实验     | 128.6 t/s | -
WikiText bench  | 127.9 t/s | 0.5% ✅
```

Baseline一致，说明数据集相同。

### **有剪枝配置一致性**

需要检查：剪枝消融实验中的"有剪枝"配置，是否与其他实验一致？

```python
# 从剪枝消融实验
Tree D=7, B=2, t=0.05: 182.7 t/s

# 从WikiText benchmark
Tree D=7, B=2, t=0.05: ??? (需要查)
```

让我检查一下...

---

## 🎯 **结论**

**无剪枝数据不可信！**

原因：
1. ❌ Path length不随深度增加
2. ❌ 吞吐量在D≥5时保持不变
3. ❌ 无剪枝的path比有剪枝短

**建议**：
1. 检查实验代码，确认是否有隐式限制
2. 重新跑无剪枝实验
3. 或者使用其他方案做消融实验

---

## 📋 **替代方案**

### **方案1: 放弃无剪枝对比**

使用3步消融实验：
```
Step 1: Baseline          128.6 t/s
Step 2: + Draft (Linear)  174.2 t/s (+35%)
Step 3: + Tree + Pruning  182.7 t/s (+5%)
```

**优点**: 数据真实可靠
**缺点**: 无法突出pruning的重要性

### **方案2: 使用不同threshold对比**

对比不同pruning threshold的效果：
```
Baseline:       128.6 t/s
Linear K=6:     174.2 t/s
Tree t=0.10:    ??? (宽松剪枝)
Tree t=0.05:    182.7 t/s (最优剪枝)
Tree t=0.01:    ??? (严格剪枝)
```

需要从WikiText参数扫描数据中提取。

### **方案3: 重新跑正确的无剪枝实验**

确保：
- 完全关闭pruning
- 没有max_nodes限制
- 正确记录树的大小

预计时间：5-10分钟

---

## 🔍 **需要进一步检查**

1. **查看WikiText参数扫描数据**
   - 是否有D=7, B=2的其他threshold配置？
   - 是否有t=1.0或t≥0.5的配置？

2. **检查实验代码**
   - `pruning_enabled=False`是否真的关闭了剪枝？
   - 是否有`max_tree_nodes`限制？

3. **查看原始日志**
   - 树的实际大小是多少？
   - 是否有警告信息？

---

**下一步：告诉我你想怎么办？**

1. 放弃无剪枝对比，用方案1（3步消融）
2. 使用方案2（不同threshold对比）
3. 重新跑正确的无剪枝实验
4. 先检查WikiText参数扫描数据，看是否有其他可用数据

