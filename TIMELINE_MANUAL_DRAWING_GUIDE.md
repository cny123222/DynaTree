# Timeline Comparison 手绘指南

## 🎯 整体布局

画布分成**3个横向的部分**，从上到下：
- **第一部分**: Autoregressive (AR)
- **第二部分**: Linear Speculative
- **第三部分**: DynaTree

每个部分都是一个"时间轴"，从左到右表示时间流逝。

---

## 🔵 Part 1: Autoregressive (AR) - 最简单

**标题**: 写 "(a) Autoregressive Decoding (AR)"

**要画的内容**:

画**5个蓝色方框**，排成一横排，用箭头连接：

```
┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐    ┌─────┐
│ LLM │ →  │ LLM │ →  │ LLM │ →  │ LLM │ →  │ LLM │
│  ↓  │    │  ↓  │    │  ↓  │    │  ↓  │    │  ↓  │
│ t₁  │    │ t₂  │    │ t₃  │    │ t₄  │    │ t₅  │
└─────┘    └─────┘    └─────┘    └─────┘    └─────┘
```

**具体步骤**:
1. 画5个长方形（蓝色边框，浅蓝色填充）
2. 每个框里写3行文字：
   - 第1行："LLM"（粗体）
   - 第2行：一个向下的箭头 "↓"
   - 第3行："t₁", "t₂", "t₃", "t₄", "t₅"（分别）
3. 用单箭头 "→" 连接这5个框
4. 在下方写一句话："Serial execution - one token per step"

**颜色建议**:
- 边框：深蓝色 (#1976D2)
- 填充：浅蓝色 (#E3F2FD)
- 箭头：灰色

**核心思想**: 表现出"串行"、"一个接一个"的感觉

---

## 🟢 Part 2: Linear Speculative - 稍微复杂

**标题**: 写 "(b) Linear Speculative Decoding"

**要画的内容**:

画**3个大框**，用粗箭头连接：

```
┌────────────┐      ┌────────────┐      ┌────────────┐
│   Draft    │  ⇒   │    LLM     │  ⇒   │   Draft    │
│   Model    │      │  Verify    │      │   Model    │
│            │      │            │      │            │
│ t₁→t₂→t₃→  │      │ [t₁...t₆]  │      │ t₃→t₄→t₅→  │
│ t₄→t₅→t₆   │      │     ↓      │      │ t₆→t₇→t₈   │
│            │      │ ✓ Accept:  │      │            │
│ Sequential │      │   t₁, t₂   │      │ Continue   │
└────────────┘      └────────────┘      └────────────┘
```

**具体步骤**:

**框1 (Draft Model - 绿色)**:
1. 画一个长方形
2. 上方写 "Draft Model"
3. 中间写 "t₁ → t₂ → t₃ → t₄ → t₅ → t₆"（表示顺序生成）
4. 下方写 "Sequential generation"（小字）

**框1到框2的箭头**:
- 用**双线粗箭头** ⇒（表示批量处理）
- 橙色

**框2 (LLM Verify - 橙色)**:
1. 画一个长方形
2. 上方写 "LLM Verification"
3. 中间写 "[t₁, t₂, t₃, t₄, t₅, t₆]"（方括号表示并行）
4. 写 "Parallel verification"
5. 用绿色写 "✓ Accept: t₁, t₂"（表示只接受了前2个）

**框2到框3的箭头**:
- 同样是双线粗箭头 ⇒
- 橙色

**框3 (Next Draft - 绿色)**:
1. 和框1类似
2. 写 "t₃ → t₄ → ..."（从t₃继续）
3. 下方写 "Continue from accepted"

**颜色建议**:
- Draft框：深绿边框 + 浅绿填充
- Verify框：深橙边框 + 浅橙填充
- 双箭头：橙色

**核心思想**: Draft是顺序的（用单箭头→），但Verify是并行的（用方括号[]）

---

## 🟣 Part 3: DynaTree - 最复杂但最重要

**标题**: 写 "(c) DynaTree (Tree-based Speculative Decoding)"

**要画的内容**:

也是**3个大框**：

```
┌────────────┐      ┌────────────┐      ┌────────────┐
│ Draft Tree │  ⇒   │    LLM     │  ⇒   │ Next Tree  │
│            │      │ TreeVerify │      │            │
│     t₁     │      │            │      │     t₄     │
│    /│\     │      │  Verify    │      │    /│\     │
│   t₂ t₃ t₄ │      │   all      │      │   ...      │
│   /│ │\ │  │      │   paths    │      │            │
│  t₅ t₆... │      │     ↓      │      │            │
│            │      │ ✓ Accept:  │      │            │
│ Multi-path │      │  t₁→t₂→t₅  │      │ From path  │
└────────────┘      └────────────┘      └────────────┘
```

**具体步骤**:

**框1 (Draft Tree - 紫色)**:
1. 画一个长方形
2. 上方写 "Draft Tree"
3. **画树形结构**（重点！）：
   - 最上面：一个节点 "t₁"
   - 从t₁画3条线向下（像Y的形状）
   - 第二层：3个节点 "t₂ₐ", "t₂ᵦ", "t₂ᶜ"
   - 再从这3个节点分别向下画线
   - 第三层：再画几个节点（可以简化，用 "..." 表示）
4. 下方写 "Multi-path exploration"

**画树的简化方法**:
```
     ○ t₁
    /│\
   / │ \
  ○  ○  ○  (t₂ₐ, t₂ᵦ, t₂ᶜ)
  │  │  │
  ○  ○  ○  (第三层)
  ⋮  ⋮  ⋮  (用省略号表示更深)
```

**框1到框2的箭头**:
- 双线粗箭头 ⇒
- 红色

**框2 (LLM TreeVerify - 红色)**:
1. 画一个长方形
2. 上方写 "LLM TreeVerify"
3. 写 "Parallel verification"
4. 写 "of entire tree"
5. **用绿色粗线**画出被接受的路径：
   - "✓ Accepted path:"
   - "t₁ → t₂ᵦ → t₃ᶜ"（举例）
   - 这条路径用绿色标注，其他路径用灰色

**框2到框3的箭头**:
- 双线粗箭头 ⇒
- 红色

**框3 (Next Tree - 紫色)**:
1. 和框1类似
2. 画一个简化的树，根节点是 "t₄"
3. 下方写 "From accepted path"

**颜色建议**:
- Tree框：深紫边框 + 浅紫填充
- Verify框：深红边框 + 浅红填充
- 双箭头：红色
- 接受的路径：绿色加粗

**核心思想**: Draft生成**树形**结构（多条路径），Verify一次性验证整棵树

---

## 🎨 整体配色总结

用**色相环**来区分三种方法：

| 方法 | 主色调 | 边框色 | 填充色 |
|------|--------|--------|--------|
| AR | 蓝色 | 深蓝 (#1976D2) | 浅蓝 (#E3F2FD) |
| Linear Draft | 绿色 | 深绿 (#388E3C) | 浅绿 (#E8F5E9) |
| Linear Verify | 橙色 | 深橙 (#F57C00) | 浅橙 (#FFF3E0) |
| Tree Draft | 紫色 | 深紫 (#7B1FA2) | 浅紫 (#F3E5F5) |
| Tree Verify | 红色 | 深红 (#C62828) | 浅红 (#FFEBEE) |

**特殊颜色**:
- **接受的token**: 绿色 (#2E7D32) 加粗
- **单箭头 →**: 灰色（表示串行）
- **双箭头 ⇒**: 橙色/红色（表示并行批处理）

---

## 📐 尺寸和间距建议

**画布**:
- 宽度：约 1200-1500px
- 高度：约 800-1000px
- 留白：四周各留 50px

**每个部分**:
- 高度：约 250-300px
- 部分之间间距：30-50px

**框的大小**:
- AR的小框：宽 120px，高 100px
- Linear/Tree的大框：宽 280-350px，高 120-150px

**字体**:
- 标题 (a/b/c)：16pt，粗体
- 框内大标题：13pt，粗体
- 框内内容：11pt，常规
- 说明文字：10pt，斜体

---

## ✨ 关键视觉元素

### 1. **箭头的区别**

**单箭头 →** (细线):
- 用于：AR的框与框之间，Linear Draft内部的token顺序
- 含义：串行、一个接一个
- 颜色：灰色

**双箭头 ⇒** (粗线):
- 用于：框与框之间（表示批处理）
- 含义：并行、批量处理
- 颜色：鲜艳（橙/红）

### 2. **树的画法**

**最简单版本** (如果不好画):
```
     t₁
    /│\
  t₂ t₃ t₄
  │  │  │
  ⋮  ⋮  ⋮
```

用小圆圈 ○ 表示节点，用直线连接。

**稍微复杂一点**:
```
       ○ t₁
      /│\
     / │ \
    ○  ○  ○
   /│  │  │\
  ○ ○  ○  ○ ○
```

**关键**: 要让人一眼看出是"树"的结构！

### 3. **接受的token标注**

用**绿色**的 ✓ 符号：
- Linear: "✓ Accept: t₁, t₂"
- DynaTree: "✓ Accepted path: t₁ → t₂ᵦ → t₃ᶜ"

这个很重要，表示哪些被接受了。

---

## 🎯 三个部分的对比

画完后，读者应该能一眼看出：

| 维度 | AR | Linear | DynaTree |
|------|----|----|----------|
| Draft方式 | 无 | 顺序（→） | 树形（⚘） |
| Verify方式 | 串行 | 并行（batch） | 并行（tree） |
| 箭头类型 | → (细) | ⇒ (粗) | ⇒ (粗) |
| 接受效率 | 低（1个/次） | 中（2-3个/次） | 高（4-6个/次） |
| 视觉特征 | 一字排开 | 两阶段 | 树形扩展 |

**对比要明显**！

---

## 💡 绘制技巧

### 使用什么工具？

**推荐工具**（按难度）:

1. **PowerPoint / Keynote** ⭐⭐⭐⭐⭐
   - 最简单！
   - 插入→形状→矩形、箭头
   - 可以精确对齐
   - 导出为PDF

2. **draw.io / diagrams.net** ⭐⭐⭐⭐
   - 在线免费
   - 专业画图工具
   - 有很多模板
   - https://app.diagrams.net/

3. **Figma** ⭐⭐⭐⭐
   - 专业设计工具
   - 协作方便
   - 需要注册

4. **LaTeX (TikZ)** ⭐⭐
   - 最专业，但最难
   - 适合已经熟悉LaTeX的人

5. **手绘 + 扫描** ⭐
   - 如果画得好看也行
   - 需要清晰的线条

**我推荐用 PowerPoint！** 最简单，效果也很好。

### PowerPoint 快速步骤

1. **新建幻灯片**，设置大小为 16:9

2. **画AR部分**:
   - 插入 → 形状 → 矩形（画5个）
   - 右键 → 设置形状格式 → 填充（浅蓝），边框（深蓝）
   - 插入文本框，写 "LLM", "↓", "t₁"
   - 插入 → 形状 → 箭头（连接框）

3. **画Linear部分**:
   - 同样插入矩形（3个大框）
   - 绿色、橙色、绿色
   - 插入 → 形状 → 块状箭头（粗箭头）

4. **画Tree部分**:
   - 插入矩形（3个）
   - **画树**: 插入 → 形状 → 圆形（节点）+ 直线（连接）
   - 或者直接插入 → SmartArt → 层次结构

5. **对齐**:
   - 选中所有对象
   - 右键 → 对齐 → 居中对齐

6. **导出**:
   - 文件 → 导出 → PDF
   - 或 文件 → 另存为 → PNG (选高分辨率)

---

## ⚡ 快速版本（如果时间紧）

如果时间很紧，可以简化：

### 最小化版本

1. **AR**: 画3个框（而不是5个）
2. **Linear**: 只画2个框（Draft + Verify）
3. **Tree**: 树只画2层（而不是3-4层）

**但要保留的核心**:
- ✅ AR用单箭头 →
- ✅ Linear/Tree用双箭头 ⇒
- ✅ Tree要有树的形状（哪怕只有2层）
- ✅ 绿色的 ✓ 标注接受的token

---

## 🎨 最终检查清单

画完后，检查这些：

- [ ] 三个部分清晰分开
- [ ] 每个部分有标题 (a), (b), (c)
- [ ] AR看起来是"串行"的（一个接一个）
- [ ] Linear看起来是"两阶段"的（Draft → Verify）
- [ ] Tree有明显的"树形"结构
- [ ] 颜色区分明显（蓝、绿/橙、紫/红）
- [ ] 箭头类型正确（单 → vs 双 ⇒）
- [ ] 有绿色的 ✓ 标注
- [ ] 字体清晰易读
- [ ] 整体看起来专业、学术

---

## 📸 示意草图

最后，我给你画个ASCII的整体布局感觉：

```
╔═══════════════════════════════════════════════════════════╗
║  (a) Autoregressive Decoding (AR)                         ║
║  ┌───┐ → ┌───┐ → ┌───┐ → ┌───┐ → ┌───┐                   ║
║  │ L │   │ L │   │ L │   │ L │   │ L │                   ║
║  │ L │   │ L │   │ L │   │ L │   │ L │                   ║
║  │ M │   │ M │   │ M │   │ M │   │ M │                   ║
║  │ ↓ │   │ ↓ │   │ ↓ │   │ ↓ │   │ ↓ │                   ║
║  │t₁ │   │t₂ │   │t₃ │   │t₄ │   │t₅ │                   ║
║  └───┘   └───┘   └───┘   └───┘   └───┘                   ║
║  Serial execution - one token per step                    ║
╠═══════════════════════════════════════════════════════════╣
║  (b) Linear Speculative Decoding                          ║
║  ┌──────────┐      ┌──────────┐      ┌──────────┐        ║
║  │  Draft   │  ⇒   │   LLM    │  ⇒   │  Draft   │        ║
║  │  Model   │      │  Verify  │      │  Model   │        ║
║  │          │      │          │      │          │        ║
║  │ t₁→t₂→..│      │ [t₁..t₆] │      │ t₃→t₄→..│        ║
║  │          │      │    ↓     │      │          │        ║
║  │Sequential│      │✓ Accept: │      │ Continue │        ║
║  │          │      │  t₁, t₂  │      │          │        ║
║  └──────────┘      └──────────┘      └──────────┘        ║
║  Draft sequential, verify parallel                        ║
╠═══════════════════════════════════════════════════════════╣
║  (c) DynaTree (Tree-based Speculative Decoding)           ║
║  ┌──────────┐      ┌──────────┐      ┌──────────┐        ║
║  │   Tree   │  ⇒   │   LLM    │  ⇒   │   Tree   │        ║
║  │   Draft  │      │TreeVerify│      │  Draft   │        ║
║  │          │      │          │      │          │        ║
║  │    t₁    │      │  Verify  │      │    t₄    │        ║
║  │   /│\    │      │   all    │      │   /│\    │        ║
║  │  t₂t₃t₄  │      │  paths   │      │   ...    │        ║
║  │  /│ │\   │      │    ↓     │      │          │        ║
║  │ t₅ ... │      │✓ Accept: │      │          │        ║
║  │          │      │ t₁→t₂→t₅ │      │          │        ║
║  │Multi-path│      │          │      │From path │        ║
║  └──────────┘      └──────────┘      └──────────┘        ║
║  Tree draft + parallel tree verification                  ║
╚═══════════════════════════════════════════════════════════╝
```

---

## 🎯 核心信息

画完这个图后，读者应该**5秒内**看出：

1. **AR = 慢** - 一个一个来
2. **Linear = 快一些** - 有draft帮忙，但draft还是顺序的
3. **DynaTree = 最快** - draft是树形的，explore多条路径

这就是这个图的全部目的！

---

**祝你画图顺利！** 🎨

如果有任何问题，随时问我！

