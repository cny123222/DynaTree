# Figure 1（Architecture Overview / Fig.~\ref{fig:arch}）中文画图说明书（整合版）

> 你只需要照着“版式 + 尺寸 + 连接表”画，不需要理解算法。
> 目标：让读者 10 秒内看懂一次迭代：
> **Prefix/KV → Draft Tree → Adaptive Pruning → Flatten+Mask → Target Verify → Greedy Select+Commit → KV 更新 → Next iter**。

---

## 0. Quickstart（10 分钟照抄流程）

1) 在 Figma 新建 Frame：**1600×900**（横向），背景白。
2) 画 1 个模块卡片：**220×300**，圆角 **16**，描边 **2**（#2F2F2F）。
3) 复制成 6 个模块，横向排列，**间距 30**，顶边对齐。
4) 按配色表给 6 个模块填充背景色。
5) 依次在模块内部摆放小组件（第 3 节给了像素级规格）。
6) 画 5 条主流程实线箭头：(1)→(2)→(3)→(4)→(5)→(6)。
7) 画 1 条底部虚线回环箭头：(6)→(1)，文字 `t ← t + L`。
8) 检查缩放到 50% 仍能读清（不清就把正文字号从 14 调到 15）。
9) 导出 PDF（矢量）。
10) 文件命名建议：`figures/fig-arch.pdf`。

---

## 1. 工具与导出

- **推荐工具**：Figma（首选）；draw.io 可作为备选。
- **导出格式**：PDF（矢量）优先。

---

## 2. 全局规范（你只要按这一套，图就“像论文”）

### 2.1 画布与对齐

- Frame：1600×900
- 外边距（画面四周留白）：60 px
- 6 个模块卡片：宽 220 / 高 300；水平间距 30；**顶边对齐**。

### 2.2 字体

- 标题：Inter/Helvetica，**18pt，600**，颜色 `#111111`
- 正文：Inter/Helvetica，**14pt，400**，颜色 `#222222`，行距 1.25
- 小标注（节点名/小标签）：10–12pt

### 2.3 线条与箭头

- 模块描边：2px `#2F2F2F`
- 模块内细线（树/图标连线）：2px `#6B7280`
- 主流程箭头：3px `#2F2F2F` 实线，实心三角箭头
- 回环箭头：3px `#6B7280` 虚线（Dash 8 / Gap 6），实心三角箭头

### 2.4 配色（固定用这 6 个填充色）

- (1) Prefix/KV：`#F3F4F6`
- (2) Draft (M_D)：`#E8F1FF`
- (3) Pruning：`#FFF4E6`
- (4) Flatten+Mask：`#F1F5F9`
- (5) Verify (M_T)：`#F3E8FF`
- (6) Commit：`#ECFDF5`

---

## 3. 总体布局（模块摆放 + 连线表）

### 3.1 模块顺序（从左到右）

(1) Prefix\n(2) Draft model M_D\n(3) Adaptive pruning\n(4) Flatten + mask\n(5) Target model M_T\n(6) Select & commit

### 3.2 连线表（只按这个连，绝不会错）

- 主流程（实线）：(1)→(2)→(3)→(4)→(5)→(6)
- 回环（虚线）：(6)→(1)，文字：`next iteration:  t ← t + L`

### 3.3 箭头对齐规则（避免歪）

- 主流程箭头统一连接到模块的“中线”：
  - 从左模块右边缘中点 → 右模块左边缘中点。
- 回环箭头走底部：从 (6) 底边绕到 (1) 底边。

---

## 4. 模块内部摆放（像素级施工图）

> 每个模块卡片都是 220×300。
> 统一内边距（padding）：**16 px**。
> 标题区高度：**28 px**。
> 内容区起始 y：**52 px**（=16 + 28 + 8）。

下面对 6 个模块分别给出：**内部组件清单 + 尺寸 + 位置**。

---

### (1) Prefix 模块（左 prefix 横条 + 右 KV 叠层）

**标题（放左上）：** `Prefix`

**图形区（y 从 52 开始）：**

1) Prefix 横条（横向）
- 形状：圆角矩形
- 尺寸：**110×18**，圆角 6
- 填充：`#FFFFFF`；描边 1px `#6B7280`
- 位置：左上角 **(x=16, y=72)**
- 文本：居中写 `x_{1:t}`（字号 12）

2) KV cache 叠层（竖向叠 3 层）
- 每层矩形：**54×18**，圆角 4，填充白，描边 1px `#6B7280`
- 叠层偏移：每层向右下偏移 **6 px**
- 第 1 层左上角：**(x=150, y=66)**
- 第 2 层： (156, 72)
- 第 3 层： (162, 78)
- 在最上层右侧或下方放小字：`KV`（字号 12）

**底部文字区（靠下，2 行）：**
- `Prompt / prefix  x_{1:t}`
- `KV cache (prefix)`

---

### (2) Draft model M_D（固定 3 层小树）

**标题：** `Draft model  M_D`

**树的统一样式：**
- 节点：圆形直径 **20**；白底；描边 1px `#6B7280`
- 节点字：10pt（u0/u1/...）
- 连线：2px `#6B7280`

**节点“中心点坐标”（照抄）：**
- `u0`：(110, 78)
- `u1`：(70, 125)
- `u2`：(110, 125)
- `u3`：(150, 125)
- `u4`：(60, 172) 连到 u1
- `u5`：(110, 172) 连到 u2
- `u6`：(160, 172) 连到 u3

**小标注（可选）：**
- 在 (150, 58) 放 `top-B`
- 在 (90, 192) 放 `depth D`

**底部文字区（3 行）：**
- `Tree drafting`
- `top-B expansion`
- `depth D`

---

### (3) Adaptive pruning（复制树 + 灰掉两条分支 + ×）

**标题：** `Adaptive pruning`

**做法：**直接复制模块 (2) 的树。

**固定剪掉两条：**
- 剪 `u3→u6`：
  - u6 填充改 `#E5E7EB`
  - 线 `u3-u6` 改 `#CBD5E1`
  - 在 u6 右上方放 `×`（字号 14，颜色 `#DC2626`，位置约 (170, 160)）
- 剪 `u1→u4`：
  - u4 填充 `#E5E7EB`
  - 线 `u1-u4` 改 `#CBD5E1`
  - 在 u4 左上方放 `×`（位置约 (45, 160)）

**保留路径：**让 `u0→u2→u5` 仍保持正常灰线。

**底部文字区（3 行）：**
- `prob. threshold  τ`
- `node budget  N_max`
- `prune low-prob branches`

---

### (4) Flatten + mask（左边 4 条列表，右边 4×4 网格）

**标题：** `Flatten + mask`

**整体分两列：**左列宽 110；右列宽 78；中间间距 10。

1) 左列：BFS 列表（注意：是“竖着排的四条横条”）
- 顶部小字：`BFS order` 放在 (16, 60)
- 列表条（画 4 条横条）：
  - 每条：**98×14**，圆角 4，白底，描边 1px `#6B7280`
  - 第 1 条左上角：**(16, 78)**
  - 条间距：8（y=78,100,122,144）
  - 条右侧文本（字号 12）：依次写 `u0` / `u1` / `u2` / `...`

2) 右列：mask 网格（严格 4×4）
- 顶部小字：`mask` 放在 (150, 60)
- 网格左上角：**(150, 78)**
- 格子大小：**12×12**；格子间距：2
- 填色规则（保证看起来像因果即可）：
  - 上三角填 `#111827`
  - 其余填 `#E5E7EB`

**底部文字区（2 行）：**
- `BFS flatten: [u0,u1,u2,...]`
- `tree causal mask`

---

### (5) Target model M_T（左 4 层 Transformer，右 6 格 logits）

**标题：** `Target model  M_T`

1) Transformer 层堆叠（4 层）
- 每层：**90×18**，圆角 6，白底，描边 1px `#6B7280`
- 第 1 层左上角：**(30, 78)**
- 层间距：10（y=78,106,134,162）
- 在最上层写 `Transformer`（字号 11）

2) 输出 logits 条带（横向 6 格）
- 外框：**90×18**，圆角 6，白底，描边 1px `#6B7280`
- 左上角：**(130, 120)**
- 上方写 `logits`（130, 100）
- 用 5 条竖线分割成 6 格（线宽 1px `#CBD5E1`）

**底部文字区（3 行）：**
- `Verify all nodes`
- `one forward pass`
- `logits / accept signals`

---

### (6) Select & commit（树 + 绿色高亮路径 + L 标签 + cache）

**标题：** `Select & commit`

1) 树：复制模块 (2) 的树（位置不变）。

2) 高亮路径（固定高亮 u0→u2→u5）
- 把 `u0-u2`、`u2-u5` 两段线复制一层置顶：
  - 线宽 4px，颜色 `#16A34A`
- 可选：u0/u2/u5 外圈加绿色描边 2px。

3) L 标签（绿色小胶囊）
- 尺寸：**24×16**，圆角 6
- 填充：`#16A34A`；文字白 `#FFFFFF`
- 写 `L`
- 位置：左上角约 **(98, 186)**（靠近 u5 下方）

4) cache 更新图标（右下角）
- 两层小矩形叠起来：每个 **42×14**，圆角 4，白底，描边 1px `#6B7280`
- 最上层左上角：**(150, 200)**
- 旁边两行小字（字号 11）：`crop` / `rebuild`

**底部文字区（3 行）：**
- `longest valid path`
- `commit L tokens (+1)`
- `update KV cache`

---

## 5. 导出与自检（你画完一定做）

### 5.1 导出

- 选中整个 Frame → Export → PDF（矢量）。

### 5.2 5 秒自检（不通过就回去改）

读者能否一眼回答：
- 输入是什么？（prefix + KV）
- 谁生成树？（M_D）
- 为什么树不会爆？（τ + N_max）
- 为什么能并行验证？（flatten + mask + M_T one forward）
- 最终提交什么？（longest valid path, commit L）
- 下一轮怎么继续？（KV update + loop）

---

## 6. 常见误区（避免返工）

- 不要把 Fig1 画成代码流程图（太细）。
- 不要把 mask 的严格定义放在 Fig1（细节留给 Fig2）。
- 不要画很深的树（3 层足够表达“树”）。
- 不要写实验配置/脚本/文件名。
